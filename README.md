# Error-studies

Вариант текста на английском языке следует сразу после текста на русском.
The English version of the text follows immediately after the Russian text.

Начала ошибковедения.

Содержание

1. Введение. 
2. Классификация ошибок. 
3. Причины ошибок.
4. Объективные источники информации о возникших ошибках.
5. Стандартный алгоритм исправления ошибки.
6. Профилактика ошибок. 
7. Послесловие.

.

1. Введение

1.1. История вопроса.

Уже делались попытки разработать дисциплину изучающую ошибки как феномен, правда, это касалось больше вопросов лингвистики.
Эрратология - (от лат errata — ошибки), — это прикладное направление лингвистики, изучающее различные случаи нарушений собственно Языковых норм (см.), Коммуникативных норм (см.) и Этико-речевых норм (см.).
Выделяется в противовес Ортологии (см.), изучающей языковую норму, её функционирование и историческую изменчивость в соотношении с системой языка и узусом. [https://didacts.ru/termin/oshibkovedenie.html]

Термин «Ошибковедение» предложен Георгием Гуревичем в научно-фантастическом рассказе «Свойственно ошибаться» 
"Ошибковедение неисчерпаемо, бесконечно и вечно. Бесконечно потому, что бесконечна природа. Вечно потому, что надо знать все, чтобы устранить все ошибки. Но чтобы узнать все, необходима вечность"
[http://books.rusf.ru/unzip/add-on/xussr_gk/gurevg49.htm?1/3]

так же ошибковедение упоминается на ресурсах:
https://vikent.ru/enc/4921/
https://cyberleninka.ru/article/n/erratologiya-kak-obschaya-teoriya-oshibok/viewer
https://shlahter.livejournal.com/36109.html

Во всех этих источниках ошибковедение рассматривается либо с узко профессиональной точки зрения либо довольно поверхностно. Нигде не предлагается полноценная классификация ошибок, не рассматриваются наиболее часто встречающиеся причины возникновения ошибок, эффективные методы поиска причин ошибок, не даются оценки затрат времени на обработку ошибок, не рассматривается эффективность мер по снижению вероятности возникновения ошибок до приемлемого минимума, не предлагаются метрики позволяющие оценить относительное количество ошибок, не делается попыток понять каким должен быть этот минимум. 

1.2. Мотивация разработки курса.

Ошибки возникают всегда в любой деятельности, если это не самые примитивные виды работ. Если взять, например, работу разработчика, программиста, то при том уровне сложности задач, которые приходится решать, при той многочисленности технологий и инструментов, которые приходится применять, при той комплексности методов и подходов, которые приходится использовать, писать код «сразу без ошибок» практически невозможно. Даже при самом тщательном и дальновидном продумывании и планировании своей работы исключить возникновение ошибок невозможно. 
Процессом исправления ошибок может быть выстроен по разному. 
При неэффективной организации, работник (например разработчик) тонет в мириадах «неисправимых» ошибок, очень подолгу мучается с поиском их причин, и на это уходит львиная доля времени всей разработки,  как следствие срываются сроки, код получается низкого качества, и он плохо работает при его практической эксплуатации (в проде). 
При правильной постановке процесса исправления ошибок, работник (разработчик) тратит на исправление ошибок относительно небольшое количество времени и в итоге получает эффективный качественный код. 
Важно при этом понимать, что в крупных приложениях, при самом умном подходе, свести количество ошибок к нулю невозможно в принципе. Есть некоторое минимальное количество ошибок, такое, что исправление одной из них приводит к возникновению двух новых. Важно добиться того чтобы наличие этих ошибок не делало приложение непригодным к эксплуатации и было бы почти незаметным пользователю.
На сегодняшний день уже накоплен большой опыт обработки ошибок, поиска причин возникновения, способов  контроля и методов минимизации количества ошибок. Очевидно назрела необходимость проанализировать этот опыт, систематизировать накопленные знания и сформулировать базовые принципы и подходы работы с ошибками. 


1.3. Предмет изучения и определения.

Происхождение термина - «ошибка» буквально понималась как промах, неточное попадание при ударе.
Происхождение слова ошибка в этимологическом онлайн-словаре Успенского Л. В.[https://lexicography.online/etymology/о/ошибка]

В нашем понимании, ошибка это, непреднамеренное действие или, наоборот, не выполнение необходимого действия, повлекшее за собой возникновение препятствия для  правильной работы и получения требуемого верного результата. То есть, мы исходим из того, что у ошибки всегда есть причина её возникновения — ошибки не возникают сами по себе.   

Лично мне очень нравится определение ошибки как тупиковой ветви в графе возможных действий предпринимаемых для реализации поставленной задачи. Если следовать теории графов, то такой граф должен быть сетевым, ориентированным, взвешенным, без петель.  Выполнение задачи, в таком случае, можно представить как поиск в этом графе пути приводящего к требуемому результату (хотя бы одного, а в идеале, самого «недорого» по суммарному весупройденных рёбер). Возникновение ошибок, в этом случае, представляется в виде захода в ветвь, которая заведомо не может привести к решению («тупик»). Такое представление позволяет наметить направление построения в будущем механизма автоматизированной разработки и отладки программных приложений с помощью интеллектуального ассистента на базе нейросетевых решений или с помощью инструментов дискретной оптимизации.
Для наглядности я буду использовать практический материал из сферы IT и даже из ещё более узкой области — из  разработки ПО (преимущественно на Java, JavaScript или Python), но при относительно небольшой коррекции все те же размышления и методы могут быть применены и к другим отраслям.


2. Классификация ошибок

Правильнее всего будет начать рассмотрение этой темы с анализа разновидностей ошибок как таковых, группировки их по характерным признакам и выяснения особенностей каждой группы. И, как я уже говорил, удобнее всего рассматривать ошибки возникающие в программировании.

2.1. Синтаксические — ошибки написания операторов языка программирования. Современные среды разработки ПО, такие как IDEA, NetBeans, Eclips помогают разработчику минимизировать количество допущенных ошибок путём постоянного контроля синтаксиса и подачи сигналов о допущенных синтаксических ошибках в виде выделения красным цветом неверно записанных элементов кода, или подчёркивания красной волнистой чертой фрагментов кода содержащих скрытые синтаксические ошибки. Например, несоответствие типов переменных передаваемых на вход функции и типов переменных указанных в определении этой функции.	

2.2. Настроечные — ошибки всевозможных настроек в различных конфигурационных файлах проекта, среды разработки, среды исполнения, операционной системы и пр.

2.2.1. Отсутствие необходимых библиотек. 

2.2.2. Не соответствие используемых в разрабатываемом приложении библиотек целям их использования (например, java.utils.date и java.sql.date).

2.2.3. Неверно заданные параметры в настроечных файлах проекта, таких как:

2.2.3.1. pom.xml,

2.2.3.2. build.gradle,

2.2.3.3. application.property 

2.2.3.4. application.yaml

2.2.3.5. application-docker.property 

2.2.3.6. lombok.config

2.2.3.7. Dockerfile

2.2.4. Неверно заданные параметры в конфигурационных файлах хранящихся вне приложения

2.2.4.1. На сервере конфигураций.

2.2.4.2. В СУБД — например в PostgreSQL дефолтное количество подключений к базе данных ограничено 100 штуками, и при исчерпании этого количества, при попытке установить 101-е соединение возникает ошибка доступа, устранить которую можно просто увеличив параметр max_connections в postgresql.conf. 

2.3. Интеграционные - при взаимодействии компонентов сложных систем между собой также могут возникать разнообразные ошибки. В разработке ПО эти взаимодействия называют интеграциями.  Типичные ошибки интеграции:

2.3.1. несоответствие протоколов установления соединения,

2.3.2. ошибки адреса для установления соединения,

2.3.3. ошибки параметров используемых при установке соединения,

2.3.4.  несоответствие протоколов передачи данных.


2.4. Логические — ошибки в построении обработки используемых данных нарушающие прикладную логику системы (например, вычисление значения арифметического выражения, содержащего операцию деления при том, что значения выражения стоящего в знаменателе, по какой-то причине, оказывается нулевым).

2.4.1. Алгоритмические - ошибки реализации типовых (или индивидуально разработанных) алгоритмов. Типичный пример — фильтрация списка с заведомо невыполнимым условием отбора. 

2.4.2. Структурные — связанные с использованием таких структур как List, Map, Stack, Queue, Tree и пр.

2.4.3. Ошибки связанные с БД:

2.4.3.1. несоответствие структуры таблиц в БД и структуры классов получающих данные из БД или методов обрабатывающ
их эти данные.

2.4.3.2. невалидные данные в БД,

2.4.3.3. неверное использование внешних ключей таблиц и отношений типа «один ко многим», «многие ко многим»,

2.4.4. Архитектурные — структура приложения, отраженная в архитектурных схемах, может содержать серьёзные изъяны, которые приводят к большим затруднениям при разработке и, как следствие, быть почвой для возникновения серьёзных ошибок. Например, перегрузка компонентов приложения множественным разнородным функционалом, часто приводит к печально известной «высокой связности», которая в свою очередь, на достаточно продвинутых этапах разработки приводит к ошибкам типа «за ухо дёрнул — нос отвалился»     

2.4.5. Ошибки дат.

В практической деятельности используется большое количество разных форматов записи даты. Различаться могут разделители, например 2024.10.15 и 2024-10-15. Различаться может последовательность компонентов даты, например 2024.10.15 и 15/10/2024. Формат даты может включать или не включать время, разделитель T, часовой пояс Z+003 и прочее. Так же дату можно хранить в виде большого целого числа — количества  секунд, прошедших с 0 часов, 0 минут, 0секунд 1 января 1970 года. 
Приравнивание значений датовых переменных имеющих разный формат приводит к синтаксическим ошибкам, а неверная конвертация одного формата в другой к ошибкам логическим свойства.   

2.5. Системные — несовместимость используемых компонентов и возможностей операционной системы.

2.5.1. Ошибки несовместимости версии ОС и версий используемых JRE/JDK.

2.5.2. Ошибки несовместимости устаревшей версии ОС и новой версии интегральной среды разработки или используемых библиотек или прочих инструментов.

2.5.3. Ошибки несовместимости современной версии ОС и устаревших версий интегральной среды разработки или используемых библиотек или прочих инструментов.

2.5.4. Ошибки использования системных ресурсов доступ к которым ограничен.

2.6. Ошибки доступа - часто разрабатываемый код использует ресурсы размещённые на удалённых серверах. Доступ на эти сервера регламентируется владельцем ресурса и может быть ограничен кругом доверенных агентов, и если разработчик  не выполнил требования для получения доступа (в настройках приложения), его код не сможет выполниться корректно, что приведёт к возникновению ошибки.

2.6.1. ошибки роли — доступы к различным ресурсам обычно выдаются не каждому отдельному пользователю, а группе пользователей, выступающих в определённой роли. Чтобы получить определённые доступы в большинстве Линукс-подобных ОС, пользователю необходимо быть включенным в соответствующую группу, например, для получения доступов на уровне «super user» нужно, чтобы админ ресурса внёс пользователя в группу «root».

2.6.2. ошибки сертификата — многие системы информационной безопасности требуют для обеспечения доступа к тем или иным ресурсам наличия соответствующего файла содержащего в зашифрованном виде сведений пользователе, его роли и правах доступа и отсутствие нужного сертификата может приводить к отказам разрабатываемому приложению в установлении связи или получении доступа к каким-то файлам и иным ресурсам.


2.7. Ошибки связанные с ограничениями службы безопасности — часто соблюдение требований обеспечения информационной безопасности вступают в конфликт с задачами разработки и эксплуатации ПО, что приводит к возникновению ошибок при выполнении кода ПО.


2.7.1. Часто для получения доступа к каким-то ресурсам необходимо установить настроить и запустить VPN доступ, без которого работа приложения будет блокироваться и будет возникать множество ошибок. 

2.7.2. В соответствии с требования правительства и других государственных структур (например в связи с зарубежными санкциями) служба ИБ предприятия может запретить использование некоторых видов ПО или иных средств, что в свою очередь может вызывать сбои в работе тех продуктов, которые игнорируют эти ограничения.
Я не ставлю себе цель составить справочник ошибок, заглянув в который можно было бы быстро найти причину ошибки, это практически невозможно ввиду их огромного разнообразия и постоянного пополнения множества ошибок новыми видами, что вызвано постоянным обновлением и пополнением инструментов и средств разработки. Моя цель предложить эффективный метод поиска причин ошибок (и их исправления), позволяющий сократить затраты времени на отладку ПО. 

3. Причины ошибок

Классификация ошибок тесно связана с причинами их возникновения. Для упрощения задачи, мы будем рассматривать ошибки которые вызваны одной причиной. Ошибки комплексного характера, вызванные не одной а сразу несколькими причинами, должны стать предметом отдельного исследования. 

3.1. Неверная реализация кода разработчиком — синтаксические ошибки , алгоритмические ошибки, неверное использование структур, (например, в Java объектов из фреймворка Collection), ошибки асинхронного обмена с внешними ресурсами, ошибки Flux и т.д.

3.2. Неверные настройки инструментов разработки — в файлах проекта *.yml, *.groovy, *.cfg и пр. или в классах типа DataConfig.java, CustomOpenAPI.java и т.п.

3.2.1. Неверные настройки сборщика — в java используются такие сборщики как Ant, Maven, Gradle и пр., и их работа тоже может вызывать ошибки при не правильных настройках, при сбоях работы связи (невозможность подтянуть зависимости), при конфликтах с другими инструментами.

3.2.2. Неверные настройки JVM (Java virtual machine) и JRE (Java runtime environment) – среда исполнения программного кода тоже может быть источником ошибок так как тоже содержит собственные настройки, которые могут оказаться неверными и возможны конфликты версий и ошибки интеграции с прочими компонентами.

3.2.3. Неправильное использование ресурсов и параметров ОC — ошибки взаимодействия с различными компонентами операционной системы такими как драйвера устройств, сетевые службы и пр.

3.3. Неверная реализация взаимодействия разрабатываемого приложения с компонентами прикладного окружения (микросервисами) — ошибки интеграции.

3.3.1. ошибки при использовании протоколов взаимодействия.

3.3.2. ошибки в форматах вызовов.

3.4. Ошибки обращения к БД

3.4.1. Неправильно задан сетевой адрес и/или порт и/или логин и/или пароль.

3.4.2. Неправильно выбран или настроен протокол обмена данными.


3.5. Ошибки работы связи или неверные настройки подсистем обеспечивающих связь между привлекаемыми ресурсами.

3.5.1. Неправильный формат/параметры REST-вызовов.

3.5.2. Неправильный формат/параметры вызовов брокера сообщений. 

3.6. Несоответствие версий используемых приложений/библиотек/драйверов 

3.6.1. Версии ОС, драйверов устройств, среды разработки (IDEA/NetBeans), JRE, сборщика (Maven/Gradle), вспомогательных утилит и используемых компонентов SDK могут не соответствовать друг другу в плане совместимости.


4. Объективные источники информации о возникших ошибках

Исправление ошибки предполагает однозначное понимание причины её возникновения, и для этого нужна достаточно полная информация содержащая все необходимые сведения. Такая информация может быть получена из ниже описанных источников. 

4.1. Автматические логи — среда разработки, плагины, Java-мишина, операционная система и пр. автоматически генерируют большое количество логов, существует несколько режимов логгирования от наименее информативного режима «info» и до максимально подробного «trace». В логах содержится сообщения с описанием всего происходящего во время выполнения приложения и, в первую очередь сообщения о возникших сбоях. Логи это важнейший источник информации об ошибках.   

4.2. Исключения — во многих языках реализован механизм обработки исключительных ситуаций, так называемых «Исключений» или Exceptions. При возникновении исключений почти всегда делается логгирование и в консоль выдаются подробное сообщения о возникшем исключении и причинах его возникновения.

4.3. Кроме этих случаев у разработчика есть возможность делать собственное, вспомогательное логгирование. Оно помогает отслеживать предпосылки возникновения ошибок путём помещения в лог сообщений о выполнении значимых для понимая ситуации, в которой возникла ошибка  и состоянии значимых переменных в этот  момент.



5. Стандартный алгоритм исправления ошибки.

Устранять ошибки можно по разному. 

Кто-то целиком и полностью полагается на свои опыт и интуицию и по первым словам сообщения догадывается о причинах ошибки и понимает что нужно сделать чтобы её исправить. Обычно на это способны разработчики уровня senior, с многолетним, разнообразным опытом.

Другие все надежды возлагают на всемогущий google и при малейшем непонимании копируют сообщение об ошибке в поисковую строку гугла и внимательно вычитывают многочисленные ссылки на найденные упоминания подобных сообщений. Это больше свойственно разработчикам уровня junior и midle. Беда в том, что частенько ни одна из найденных ссылок не предлагает варианта решения, который дал бы ожидаемый результат — после проверки десятков вариантов, ошибка остаётся не устранённой. 

Начинающие разработчики часто вынуждены просить помощи у более опытных коллег, поскольку испытывают затруднения даже с чтением логов и правильным  вычленением содержательных фрагментов из сообщения об ошибке. Беда если опытные коллеги сильно заняты или вовсе отсутствуют.

Справедливости ради надо сказать, что иногда возникают ошибки, сообщения о которых вызывают затруднения в понимании причин даже у очень опытных сеньёров. И для того чтобы разобраться с такими ошибками приходится собираться всей командой и устраивать «мозговой штурм». 

Хуже всего когда разработчик, не находя понятной причины возникновения ошибки начинает хаотически метаться между логом, гуглом, обращениями к коллегам и сомнительными экспериментами, а спустя какое-то время осознаёт, что уже давно ходит по замкнутому кругу из которого нет выхода. Такие ситуации могут стать причиной переутомления, выгорания, депрессии и разочарования в профессии.  

Основываясь на многолетнем опыте можно утверждать, что процесс поиска причины ошибки и её исправления может быть систематизирован и оптимизирован, а это позволит значительно сократить время которое приходится тратить на отладку ПО.

Я попытался предложить типовую последовательность действий предпринимаемых при возникновении ошибки, которая позволяла бы максимально быстро понять причину в максимально широком диапазоне разнообразия ошибок.  

Последовательность действий,  на мой взгляд, должна выглядеть так как это описано ниже. 

5.1. Чтение сообщений об ошибках и их анализ.

Умение правильно читать сообщения об ошибках, это важный навык, который не  обязательно имеется у разработчика изначально, а вырабатывается в процессе работы. 

5.1.1. Во-первых важно понимать что, при возникновении сбоя список ошибок в логе может быть очень длинным — до сотни строк. Как правило, все эти ошибки оказываются следствием некоторой «первичной» ошибки указанной в первой строке списка. Именно эту ошибку и надо проанализировать в первую очередь и определить её причину.

5.1.2. Часто сообщение о «первопричинной» ошибке оказывается очень длинным и сложным для понимания. Например, ключевые для понимания слова «column with name user_surname not exist in table user» может находиться в самом конце очень длинной фразы и пока разработчик дочитает до этого места, он может встретить несколько других «кандидатов на роль причины». Если разработчик начнёт проверять все версии начиная с первой, искать в сети описания похожих причин, проверять работу найденных рецептов, комбинировать и экспериментировать, то, в итоге, он (разраб) потратит неоправданно много своего времени. Чтобы избежать этих досадных потерь времени, желательно прежде чем строить версии о причинах, дочитать сообщение до конца, оценить каждого обнаруженного «кандидата на роль причины» с точки зрения вероятности того что причина именно в нём, и только потом приниматься за проверку каждой версии в отдельности по очереди. 

5.1.3. Часто причина ошибки заключается в неприемлемых значениях переменных, присвоение которых произошло до выполнения команды повлекшей возникновение ошибки, и чтобы понять причину, необходимо просмотреть значения этих переменных (если они логгируются). Поэтому для лучшего понимания причин ошибки полезно прочитать залоггированные значения непосредственно участвующих переменных, что бы была возможность просмотреть их текущие значения и проверить корректность. Например, часто увиденное null в значении некоторой переменной однозначно объясняет причину выкидывания исключения NullPointerException. Для того чтобы была возможность обнаружить ошибки этим способом, рекомендуется без ворчания и лени логгировать все значимые переменные.

5.2. Поиск причин возникновения ошибок.

В простых случаях из сообщения об ошибке можно легко понять в чем причина её возникновения и как её устранить, Например: 

2023-11-07 13:52:26.266 ERROR 24188 o.h.engine.jdbc.spi.SqlExceptionHelper: Колонки const не найдено в этом ResultSet’’е.

в этом сообщении сразу бросается в глаза часть фразы «Колонки const не найдено» и это явно указывает на то что разработчик допустил описку — вместо колонки cost набрал const. Нужно просто исправить имя соответствующего поля сущностного класса.
К сожалению, часто после прочтения сообщения возникает сразу несколько догадок о возможных причинах, например:

2023-11-07 14:20:45.097 DEBUG 9520 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : GET "/application/v1/project/bd196087-7eb1-4a38-9d64-b76abc6667f0", parameters={};
2023-11-07 14:20:45.106  WARN 9520 --- [nio-8080-exec-1] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'GET' not supported];
2023-11-07 14:20:45.106 DEBUG 9520 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed 405 METHOD_NOT_ALLOWED;
2023-11-07 14:20:45.115 DEBUG 9520 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : "ERROR" dispatch for GET "/error", parameters={};
2023-11-07 14:20:45.118 DEBUG 9520 --- [nio-8080-exec-1] s.w.s.m.m.a.RequestMappingHandlerMapping : Mapped to org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController#error(HttpServletRequest);
2023-11-07 14:20:45.143 DEBUG 9520 --- [nio-8080-exec-1] o.s.w.s.m.m.a.HttpEntityMethodProcessor  : Using 'application/json', given [*/*] and supported [application/json, application/*+json, application/json, application/*+json];

читая это сообщение можно предположить, что причина в том, что

-  «Request method 'GET' not supported», то есть ошибка в наботе ключевого слова “GET” — буквы E или T набраны в русской раскладке;
  
- или в том что «"ERROR" dispatch for GET "/error", parameters={}», то есть сделана ошибка в формате описания ендпоинта для команды GET

- или в том что «Using 'application/json', given [*/*] and supported [application/json, application/*+json, application/json, application/*+json]», то есть сделана ошибка в формате json объекта, получаемого при вызове.

В таких случаях нужно попытаться построить несколько версий причин ошибки и все их проверить.

Самое неприятное, это когда никаких догадок не возникает совсем ... . В таких случаях, если логи позволяют локализовать строку или блок кода, в котором возникла ошибка, есть смысл попытаться найти другое решение — переписать сбойный код используя альтернативный подход, выполняющий ту же самую задачу.



5.3. Построение гипотез о вероятной причине возникновения ошибки.

5.3.1. Первое что следует сделать при обработке ошибки, это внимательно прочитать все относящиеся к сбою сообщения. 

5.3.2. После прочтения сообщений следует попытаться классифицировать ошибку — относится ли она к ошибкам кода или к ошибкам настроек, или к ошибкам интеграции, или к ошибкам взаимодействия с системой, или к ошибкам доступа и пр. 

5.3.3. На основании полученной классификации (идеально если это будет один класс ошибок) предположить возможную причину для каждого класса — т.е. сформулировать «гипотезы».

5.4. Проверка гипотез.

5.4.1. Каждую гипотезу следует оценить с точки зрения её вероятности. 

5.4.2. Начиная с наиболее вероятной сделать проверку каждой гипотезы. 

5.5. Поиск в интернете описаний аналогичных ошибок.

5.5.1. Поиск сведений об ошибках в интернете, также сопряжён с определёнными трудностями. Связано это с тем, что сообщение об ошибке в логе может быть довольно громоздким.

Можно вставить в поисковую строки (google или yandex или duckduckgo) всё сообщение целиком, тогда поисковый сервис сам решит какие ключевые слова имеют приоритетное значение и при выдаче упорядочит ссылки в порядке релевантности именно этим ключевым словам. Полезные ссылки могут оказаться в нижней части длинного списка и вообще не попадут в поле зрения.
Правильнее всего вставить в запрос только ту часть сообщения об ошибке, которая с наибольшей вероятностью содержит указания на причину ошибки. Я обычно выбираю содержательную часть сообщения методом исключения — отбрасываю те части сообщения, которые содержат «стандартные» «предварительные» упоминания о компонентах, использованных при разработке приложения, например  …org.springframework.boot:spring-boot-starter… . После такой «очистки» сообщение сокращается и становится более прозрачным.

5.5.2. Ещё один важный аспект состоит в том, что формирование поискового запроса (с некоторых пор принято называть prompt engineering) сопряжено с пониманием механизмов работы поисковых сервисов.

Современные поисковики используют не только гигантские RegularExpressions, но уже на много чаще нейросети, реализующие алгоритмы NLP (naturale language processing). Это могут быть относительно простые решения на основе Embedding+CosinusDistance, а возможно применение архитектур типа GenerativePretrainedTransformer (GPT). 
Простейшее, и довольно эффективное, правило конструирования запроса — располагать ключевые слова в запросе в порядке убывания их значимости для смысла запроса, т.е. самые «главные» слова должны идти самыми первыми, потом уточняющие и потом сужающие круг поиска. Следует учитывать, что чем запрос короче, тем больше объём выдачи — шире охват потенциально релевантных ссылок, но и вероятность «проглядеть» самую полезную ссылку в множестве выданных ссылок выше. С другой стороны, чем длиннее запрос тем меньше в выдаче малополезных ссылок, но выше и вероятность того, что самую полезную ссылку поисковик не включит в выдачу.     

5.6. Мозговой штурм. Этот  метод следует применять тогда, когда проверены все «мыслимые» версии причин сбоя и ни одна не дала результата, а процесс поиска начал «ходить по кругу». При мозговом штурме следует привлечь достаточное количество членов команды в самых разных ролях, не только программистов бэкенда, но и фронтов и тестировщиков, и sql-разрабов и даже аналитиков — свежий взгляд любого из них может обратить внимания на фактор, который «привычно» игнорировался раньше и это станет зацепкой, которая позволит докопаться до глубоко скрытой причины.

5.7. Поиск обходных путей для решения проблемы. Часто реализованное решение, в котором возникает сбой не поддающийся исправлению, это первое что пришло в голову при первой попытке реализации задачи, и это решение не обязательно лучшее. Если вы потратили на поиск причины сбоя избыточно много времени, то это хороший повод задуматься о том, что у задачи могут быть другие решения и есть смысл попробовать реализовать какое-то из них.    


6. Профилактика ошибок

6.1. Автоматический контроль синтаксиса в среде разработки.
Как уже было сказано, все интегральные среды разработки (IDE) реализуют автоматический контроль правильности синтаксиса программного кода, корректности структуры классов и компонентов, а также полноты и непротиворечивости проекта в целом если он использует соответствующий фреймворк (SpringBoot, Vue, Angular и пр.). Очень важно уметь использовать эти возможности в полной мере — прежде чем запускать сборку проекта абсолютно необходимо добиться отсутствия в коде любых пометок указывающих на какие бы то ни было ошибки. Почти всегда при наведении курсора мыши на пометку об ошибке выпадает контекстное меню с возможными вариантами причин или предложениями по исправлению. Чаще всего ошибку можно исправить просто выбрав один из пунктов этого меню. Однако, иногда возникают ситуации когда ни один из пунктов меню не предоставляет возможности исправить ошибку или хотя бы понять в чём причина её возникновения. В связи с этим есть один лайфхак — чаще всего описание причины ошибки в контекстном меню IDE даётся очень сжато, но если сделать запуск приложения (или запустить сборку), то в процессе выполнения запуска «непонятная» ошибка также будет обнаружена и в лог будет выведено более подробное описание причин, что позволит понять что нужно сделать, что бы исправить эту ошибку .   

6.2. SonarCube.

При выкатке проекта на стенд для его использования широким кругом пользователей, в конвейере развёртывания на одном из этапов используется средство контроля «чистоты кода», например SonarCube. Это позволяет выявить фрагменты кода, в которых разработчик допустил небрежности или отступил от общепринятых стандартов разработки или сознательно/подсознательно затемнил (обфусцировал) код. У SonarCube больше 500 правил, проверка которых позволяет определить места с некачественно написанным кодом. Отступления от правил чистого кода это всегда благодатная почва для возникновения ошибок, если не прямо в данный момент, то при будущих доработках приложения. Следовать правилам чистого кода совершенно необходимо и поэтому автоматическая проверка SonarCube-ом обязательно должна быть включена в конвейер развёртывания. 

6.3. Unit-тестирование.

Написание Unit-тестов важный инструмент профилактики «скрытых» ошибок которые могут возникать как бы «сами собой». Например неосторожная «чистка данных» в БД может приводить к тому, что какие-то тесты выдадут сбой. Поэтому качественно написанные Unit-тесты способны «предупредить» разработчика о возникших проблемах ещё на этапе запуска приложения, когда ещё не поздно внести необходимые исправления, что не так болезненно, чем когда сбой возникает в процессе эксплуатации и может привести к финансовым или репутационным потерям предприятия-заказчика, а также репутационным и финансовым потерям уже самого разработчика. 


7. Послесловие

Я далёк от мысли, что мне удалось охватить все типы и виды ошибок, причины по которым они возникают, а также всё разнообразие методов поиска причин возникновения и способов исправления. Если у читателя возникнет желание улучшить этот курс, я буду только благодарен. 
Предлагаю всем желающим дополнять курс в любой его части, по любой теме, развивать методы работы с ошибками, расширять на любые другие языки программирования, любые сектора IT, любые другие отрасли где это может быть эффективно применимо. Если удобно, то можно присылать материалы для дополнения мне на почту (phaust@mail.ru), а я буду, с указанием авторства, добавлять в эту статью исправления, новые разделы новые аспекты, интересные показательные примеры и пр. 
 
.
 
.

English version below          

 
Introduction to Error Research and Error Management

1. Introduction.
2. Classification of errors.
3. Causes of errors.
4. Objective sources of information about errors that have occurred.
5. Standard algorithm for correcting errors.
6. Prevention of errors.
7. Afterword.

.

1. Introduction

1.1. History of the issue.

There have already been attempts to develop a discipline studying errors as a phenomenon, although this concerned more issues of linguistics.
Erratology - (from Latin errata - errors), is an applied direction of linguistics that studies various cases of violations of the actual Language norms (see), Communicative norms (see) and Ethical-speech norms (see).
It stands out in contrast to Orthology (see), which studies the language norm, its functioning and historical variability in relation to the language system and usage. [https://didacts.ru/termin/oshibkovedenie.html]

The term "Error studies" was proposed by Georgy Gurevich in the science fiction story "To err is natural"
"Error studies is inexhaustible, infinite and eternal. Infinite because nature is infinite. Eternal because you need to know everything to eliminate all errors. But to know everything, eternity is needed"
[http://books.rusf.ru/unzip/add-on/xussr_gk/gurevg49.htm?1/3]

Error studies is also mentioned on the following resources:
https://vikent.ru/enc/4921/
https://cyberleninka.ru/article/n/erratologiya-kak-obschaya-teoriya-oshibok/viewer
https://shlahter.livejournal.com/36109.html

In all these sources, Error studies is considered either from a narrow professional point of view or rather superficially. Nowhere is a full classification of errors offered, the most common causes of errors, effective methods for finding the causes of errors are considered, the time spent on error processing is not estimated, the effectiveness of measures to reduce the probability of errors to an acceptable minimum is not considered, metrics are not offered to assess the relative number of errors, no attempt is made to understand what this minimum should be.

1.2. Motivation for developing a course.

Errors always occur in any activity, unless it is the most primitive type of work. If we take, for example, the work of a developer, a programmer, then with the level of complexity of the tasks that have to be solved, with the multitude of technologies and tools that have to be used, with the complexity of the methods and approaches that have to be used, it is almost impossible to write code “straight away without errors”. Even with the most careful and far-sighted thinking and planning of your work, it is impossible to exclude the occurrence of errors.

The process of error correction can be built in different ways.

With an ineffective organization, an employee (for example, a developer) is drowning in myriads of “uncorrectable” errors, suffers for a very long time with the search for their causes, and this takes the lion's share of the entire development time, as a result, deadlines are missed, the code is of low quality, and it does not work well in its practical use (in production).

With the correct implementation of the error correction process, the employee (developer) spends a relatively small amount of time on error correction and ultimately receives effective, high-quality code.

It is important to understand that in large applications, with the smartest approach, it is impossible in principle to reduce the number of errors to zero. There is a certain minimum number of errors, such that correcting one of them leads to the emergence of two new ones. It is important to ensure that the presence of these errors does not make the application unusable and is almost invisible to the user.

To date, a lot of experience has already been accumulated in error processing, searching for causes, control methods and methods for minimizing the number of errors. Obviously, there is a need to analyze this experience, systematize the accumulated knowledge and formulate basic principles and approaches to working with errors.

1.3. Subject of study and definition.

Origin of the term - "error" was literally understood as a miss, an inaccurate hit when striking.
Origin of the word error in the online etymological dictionary of Uspensky L.V. [https://lexicography.online/etymology/о/ожига]

In our understanding, an error is an unintentional action or, conversely, failure to perform a necessary action, which entailed the emergence of an obstacle to correct work and obtaining the required correct result. That is, we proceed from the fact that an error always has a reason for its occurrence - errors do not occur by themselves.

Personally, I really like the definition of an error as a dead-end branch in a graph of possible actions taken to implement a given task. If we follow graph theory, then such a graph should be networked, oriented, weighted, without loops. In this case, the task execution can be represented as a search in this graph for a path leading to the required result (at least one, and ideally, the most “inexpensive” by the total weight of the edges passed). The occurrence of errors, in this case, is represented as entering a branch that obviously cannot lead to a solution (“dead end”). This representation allows us to outline the direction of building a mechanism for automated development and debugging of software applications in the future using an intelligent assistant based on neural network solutions or using discrete optimization tools. For clarity, I will use practical material from the IT sphere and even from an even narrower area - from software development (mainly in Java, JavaScript or Python), but with a relatively small correction, all the same thoughts and methods can be applied to other industries.

2. Classification of errors

It would be most correct to begin consideration of this topic with an analysis of the types of errors as such, grouping them by characteristic features and identifying the features of each group. And, as I have already said, it is most convenient to consider errors that occur in programming.

2.1. Syntactic - errors in writing operators of the programming language. Modern software development environments, such as IDEA, NetBeans, Eclips help the developer to minimize the number of errors made by constantly monitoring the syntax and giving signals about the made syntax errors in the form of highlighting incorrectly written code elements in red, or underlining code fragments containing hidden syntax errors with a red wavy line. For example, a mismatch between the types of variables passed to the input of a function and the types of variables specified in the definition of this function.

2.2. Configuration - errors of all kinds of settings in various configuration files of the project, development environment, runtime environment, operating system, etc.

2.2.1. Lack of necessary libraries.

2.2.2. The libraries used in the application under development do not correspond to the purposes of their use (for example, java.utils.date and java.sql.date).

2.2.3. Incorrectly specified parameters in the project configuration files, such as:

2.2.3.1. pom.xml,

2.2.3.2. build.gradle,

2.2.3.3. application.property

2.2.3.4. application.yaml

2.2.3.5. application-docker.property

2.2.3.6. lombok.config

2.2.3.7. Dockerfile

2.2.4. Incorrectly specified parameters in configuration files stored outside the application

2.2.4.1. On the configuration server.

2.2.4.2. In a DBMS — for example, in PostgreSQL, the default number of connections to the database is limited to 100, and when this number is exhausted, an access error occurs when trying to establish the 101st connection, which can be fixed by simply increasing the max_connections parameter in postgresql.conf.

2.3. Integration - various errors can also occur when components of complex systems interact with each other. In software development, these interactions are called integrations. Typical integration errors:

2.3.1. mismatch of connection establishment protocols,

2.3.2. connection establishment address errors,

2.3.3. errors in parameters used when establishing a connection,

2.3.4. mismatch of data transfer protocols.


2.4. Logical - errors in the construction of processing the data used that violate the application logic of the system (for example, calculating the value of an arithmetic expression containing a division operation, given that the value of the expression in the denominator, for some reason, turns out to be zero).

2.4.1. Algorithmic - errors in the implementation of standard (or individually developed) algorithms. A typical example is filtering a list with a deliberately impossible selection condition.

2.4.2. Structural - associated with the use of such structures as List, Map, Stack, Queue, Tree, etc.

2.4.3. Errors associated with the DB:

2.4.3.1. inconsistency between the structure of tables in the DB and the structure of classes receiving data from the DB or methods processing this data.

2.4.3.2. invalid data in the DB,

2.4.3.3. incorrect use of foreign keys of tables and relationships of the type "one-to-many", "many-to-many",

2.4.4. Architectural - the structure of the application, reflected in the architectural diagrams, may contain serious flaws that lead to great difficulties during development and, as a result, be the basis for the emergence of serious errors. For example, overloading application components with multiple heterogeneous functionality often leads to the infamous "high coupling", which in turn, at fairly advanced stages of development leads to errors like "pulled by the ear - the nose fell off"

2.4.5. Date errors.

In practice, a large number of different date recording formats are used. Separators may differ, for example, 2024.10.15 and 2024-10-15. The sequence of date components may differ, for example, 2024.10.15 and 15/10/2024. The date format may or may not include time, separator T, time zone Z+003, etc. The date can also be stored as a large integer - the number of seconds elapsed since 0 hours, 0 minutes, 0 seconds on January 1, 1970.

Equating the values ​​of date variables with different formats leads to syntax errors, and incorrect conversion from one format to another leads to logical property errors.

2.5. System - incompatibility of the used components and capabilities of the operating system.

2.5.1. Incompatibility errors of the OS version and the versions of the JRE/JDK used.

2.5.2. Incompatibility errors of an outdated OS version and a new version of the integrated development environment or the libraries or other tools used.

2.5.3. Incompatibility errors of a modern OS version and outdated versions of the integrated development environment or the libraries or other tools used.

2.5.4. Errors in the use of system resources with restricted access.

2.6. Access errors - frequently developed code is used


3. Causes of errors

The classification of errors is closely related to the reasons for their occurrence. To simplify the task, we will consider errors that are caused by one reason. Complex errors, caused not by one but by several reasons at once, should be the subject of a separate study.

3.1. Incorrect implementation of the code by the developer - syntax errors, algorithmic errors, incorrect use of structures (for example, in Java objects from the Collection framework), errors in asynchronous exchange with external resources, Flux errors, etc.

3.2. Incorrect settings of development tools - in the project files *.yml, *.groovy, *.cfg, etc. or in classes such as DataConfig.java, CustomOpenAPI.java, etc.

3.2.1. Incorrect settings of the collector — in Java, such collectors as Ant, Maven, Gradle, etc. are used, and their work can also cause errors due to incorrect settings, communication failures (inability to pull up dependencies), conflicts with other tools.

3.2.2. Incorrect settings of the JVM (Java virtual machine) and JRE (Java runtime environment) — the environment for executing program code can also be a source of errors, since it also contains its own settings, which may be incorrect and version conflicts and integration errors with other components are possible.

3.2.3. Incorrect use of resources and OS parameters — errors in interaction with various components of the operating system such as device drivers, network services, etc.

3.3. Incorrect implementation of interaction of the developed application with the components of the application environment (microservices) — integration errors.

3.3.1. errors in the use of interaction protocols.

3.3.2. errors in call formats.

3.4. Errors accessing the database

3.4.1. Incorrect network address and/or port and/or login and/or password.

3.4.2. Incorrectly selected or configured data exchange protocol.

3.5. Communication errors or incorrect settings of subsystems providing communication between the involved resources
3.5.1. Incorrect format/parameters of REST calls.

3.5.2. Incorrect format/parameters of message broker calls.

3.6. Mismatch of versions of used applications/libraries/drivers

3.6.1. The versions of the OS, device drivers, development environment (IDEA/NetBeans), JRE, assembler (Maven/Gradle), auxiliary utilities and used SDK components may not match each other in terms of compatibility.


4. Objective sources of information about errors that have occurred

Fixing an error requires an unambiguous understanding of the cause of its occurrence, and for this, sufficiently complete information containing all the necessary details is needed. Such information can be obtained from the sources described below.

4.1. Automatic logs — the development environment, plugins, Java machine, operating system, etc. automatically generate a large number of logs, there are several logging modes from the least informative "info" mode to the most detailed "trace". The logs contain messages describing everything that happens during the execution of the application and, first of all, messages about failures that have occurred. Logs are the most important source of information about errors.

4.2. Exceptions — many languages ​​have a mechanism for handling exceptional situations, the so-called "Exceptions". When exceptions occur, logging is almost always done and detailed messages about the exception that occurred and the reasons for its occurrence are output to the console.

4.3. In addition to these cases, the developer has the opportunity to do his own, auxiliary logging. It helps to track the prerequisites for the occurrence of errors by placing messages in the log about the execution of significant for understanding the situation in which the error occurred and the state of significant variables at that moment.


5. Standard algorithm for fixing an error.

Errors can be fixed in different ways.

Some rely entirely on their experience and intuition and guess the causes of the error from the first words of the message and understand what needs to be done to fix it. Usually, senior-level developers with many years of diverse experience are capable of this.

Others place all their hopes on the almighty Google and, at the slightest misunderstanding, copy the error message into the Google search bar and carefully read the numerous links to the found mentions of similar messages. This is more typical of junior and midle-level developers. The trouble is that often none of the found links offers a solution that would give the expected result - after checking dozens of options, the error remains unresolved.

Beginner developers often have to ask for help from more experienced colleagues, because they have difficulty even reading logs and correctly extracting meaningful fragments from an error message. It's a disaster if experienced colleagues are very busy or absent altogether.

To be fair, it must be said that sometimes errors occur, the messages about which cause difficulties in understanding the causes even for very experienced seniors. And in order to understand such errors, you have to get together with the whole team and arrange a "brainstorming".

The worst thing is when a developer, not finding a clear reason for the error, begins to rush chaotically between the log, Google, appeals to colleagues and dubious experiments, and after some time realizes that he has long been walking in a vicious circle from which there is no way out. Such situations can cause overwork, burnout, depression and disappointment in the profession.

Based on many years of experience, it can be argued that the process of finding the cause of an error and fixing it can be systematized and optimized, and this will significantly reduce the time that has to be spent on debugging software.

I tried to suggest a typical sequence of actions taken when an error occurs, which would allow one to quickly understand the cause in the widest possible range of error diversity.

The sequence of actions, in my opinion, should look as described below.

5.1. Reading and analyzing error messages.

The ability to correctly read error messages is an important skill that a developer does not necessarily have initially, but is developed in the process of work.

5.1.1. Firstly, it is important to understand that when a failure occurs, the list of errors in the log can be very long - up to a hundred lines. As a rule, all these errors are the result of some "primary" error indicated in the first line of the list. It is this error that must be analyzed first and its cause determined.

5.1.2. Often the message about the "root cause" error is very long and difficult to understand. For example, the key words for understanding "column with name user_surname not exist in table user" can be at the very end of a very long phrase, and by the time the developer reads to this place, he may come across several other "candidates for the role of the cause". If the developer starts checking all versions starting from the first one, searching the web for descriptions of similar causes, checking the work of the found recipes, combining and experimenting, then, in the end, he (the developer) will spend an unreasonably large amount of his time. To avoid these annoying losses of time, it is advisable to read the message to the end before building versions of the causes, evaluate each discovered "candidate for the role of the cause" from the point of view of the probability that the cause is in it, and only then start checking each version separately in turn.

5.1.3. Often the cause of the error lies in unacceptable values ​​of variables, the assignment of which occurred before the execution of the command that caused the error, and to understand the cause, it is necessary to view the values ​​of these variables (if they are logged). Therefore, for a better understanding of the causes of the error, it is useful to read the logged values ​​of the directly involved variables, so that it is possible to view their current values ​​​​and check their correctness. For example, the frequently seen null in the value of some variable clearly explains the reason for throwing a NullPointerException. In order to be able to detect errors this way, it is recommended to log all significant variables without grumbling and laziness.

5.2. Searching for the causes of errors.

In simple cases, from the error message, you can easily understand the cause of its occurrence and how to fix it. For example:

2023-11-07 13:52:26.266 ERROR 24188 o.h.engine.jdbc.spi.SqlExceptionHelper: No const columns found in this ResultSet.

The part of the phrase “No const columns found” immediately catches the eye in this message, and this clearly indicates that the developer made a typo — he typed const instead of the cost column. You just need to correct the name of the corresponding field of the entity class.
Unfortunately, often after reading the message, several guesses about possible causes arise at once, for example:

2023-11-07 14:20:45.097 DEBUG 9520 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet         : GET "/application/v1/project/bd196087-7eb1-4a38-9d64-b76abc6667f0" , parameters={} 
2023-11-07 14:20:45.106 WARN 9520 --- [nio-8080-exec-1] .w.s.m.s.DefaultHandlerExceptionResolver   : Resolved [org.springframework.web.HttpRequestMethodNotSupportedException: Request method 'GET' not supported ] 
2023-11-07 14:20:45.106 DEBUG 9520 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet         : Completed 405 METHOD_NOT_ALLOWED 
2023-11-07 14:20:45.115 DEBUG 9520 --- [nio-8080-exec -1] o.s.web.servlet.DispatcherServlet        : "ERROR" dispatch for GET "/error", parameters={} 
2023-11-07 14:20:45.118 DEBUG 9520 --- [nio-8080-exec-1] s.w.s.m.m.a. RequestMappingHandlerMapping : Mapped to org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController#error(HttpServletRequest)
2023-11-07 14:20:45.143 DEBUG 9520 --- [nio-8080-exec-1] o.s.w.s.m.m.a.HttpEntityMethodProcessor   : Using 'application /json', given [*/*] and supported [application/json, application/*+json, application/json, application/*+json]

reading this message, one can assume that the reason is that

- «Request method ' GET' not supported», that is, an error in typing the keyword “GET” — the letters E or T are typed in the Russian layout;

- or that ""ERROR" dispatch for GET "/error", parameters={}", that is, an error was made in the format of the endpoint description for the GET command

- or that "Using 'application/json', given [* /*] and supported [application/json, application/*+json, application/json, application/*+json]», that is, an error was made in the json format of the object received during the call.

In such cases, you need to try to build several versions of the reasons errors and check them all.

The most unpleasant thing is when no guesses arise at all ... . In such cases, if the logs allow you to localize the line or block of code in which the error occurred, it makes sense to try to find another solution - rewrite the faulty code using an alternative an approach that accomplishes the same task.

5.3. Building hypotheses about the probable cause of the error.

5.3.1. The first thing to do when processing an error is to carefully read all the messages related to the failure.

5.3.2. After reading the messages, you should try to classify the error - whether it relates to code errors, or to configuration errors, or to integration errors, or to system interaction errors, or to access errors, etc.

5.3.3. Based on the resulting classification (ideally, if it is one class of errors), suggest a possible cause for each class - i.e. formulate "hypotheses".

5.4. Testing hypotheses.

5.4.1. Each hypothesis should be assessed in terms of its probability.

5.4.2. Starting with the most probable, test each hypothesis.

5.5. Searching the Internet for descriptions of similar errors.

5.5.1. Searching for information about errors on the Internet is also associated with certain difficulties. This is due to the fact that the error message in the log can be quite cumbersome.

You can paste the entire message into the search bar (google or yandex or duckduckgo), then the search service itself will decide which keywords have priority and, when issuing, will sort the links in order of relevance to these keywords. Useful links may end up at the bottom of a long list and will not be visible at all.

The best way is to paste into the query only that part of the error message that most likely contains indications of the cause of the error. I usually select the meaningful part of the message by the exclusion method - I discard those parts of the message that contain "standard" "preliminary" mentions of the components used in developing the application, for example ...org.springframework.boot:spring-boot-starter... . After such "cleaning", the message is shortened and becomes more transparent.

5.5.2. Another important aspect is that the formation of a search query (for some time now it has become customary to call prompt engineering) is associated with an understanding of the mechanisms of search services.

Modern search engines use not only giant RegularExpressions, but much more often neural networks implementing NLP (natural language processing) algorithms. These can be relatively simple solutions based on Embedding + CosinusDistance, and it is possible to use architectures such as Generative Pretrained Transformer (GPT).

The simplest and quite effective rule for constructing a query is to arrange keywords in the query in descending order of their importance for the meaning of the query, i.e. the most “important” words should come first, then clarifying ones, and then narrowing the search range. It should be taken into account that the shorter the query, the greater the volume of results - the wider the coverage of potentially relevant links, but also the probability of “overlooking” the most useful link in the set of links issued is higher. On the other hand, the longer the query, the fewer unhelpful links will be returned, but the probability that the search engine will not include the most useful link in the results is also higher.

5.6. Brainstorming. 

This method should be used when all "imaginable" versions of the failure causes have been checked and none have yielded a result, and the search process has started to "go in circles". During brainstorming, it is necessary to involve a sufficient number of team members in a variety of roles, not only backend programmers, but also frontend developers and testers, SQL developers and even analysts - a fresh look from any of them can draw attention to a factor that was "usually" ignored before and this will become a clue that will allow you to get to the bottom of a deeply hidden cause.

5.7. Search for workarounds to solve the problem. Often, the implemented solution, in which a failure occurs that cannot be corrected, is the first thing that came to mind during the first attempt to implement the task, and this solution is not necessarily the best. If you have spent too much time searching for the cause of the failure, then this is a good reason to think about the fact that the problem may have other solutions and it makes sense to try to implement one of them.

6. Error Prevention

6.1. Automatic Syntax Check in the Development Environment.

As already mentioned, all integrated development environments (IDE) implement automatic check of the correctness of the program code syntax, the correctness of the class and component structure, as well as the completeness and consistency of the project as a whole if it uses the appropriate framework (SpringBoot, Vue, Angular, etc.). It is very important to be able to use these features to the fullest extent - before starting the project build, it is absolutely necessary to ensure that the code does not contain any marks indicating any errors. Almost always, when you hover the mouse cursor over an error mark, a context menu appears with possible causes or suggestions for correction. Most often, an error can be corrected simply by selecting one of the items in this menu. However, sometimes situations arise when none of the menu items provides an opportunity to correct the error or at least understand the reason for its occurrence. In this regard, there is one life hack - most often the description of the cause of the error in the IDE context menu is given very briefly, but if you launch the application (or run the build), then during the launch process the "incomprehensible" error will also be detected and a more detailed description of the causes will be displayed in the log, which will allow you to understand what needs to be done to fix this error.

6.3. SonarCube.

When rolling out a project to a stand for its use by a wide range of users, a "code cleanliness" control tool, such as SonarCube, is used at one of the stages in the deployment pipeline. This allows you to identify code fragments in which the developer was careless or deviated from generally accepted development standards or consciously / subconsciously obscured (obfuscated) the code. SonarCube has more than 500 rules, checking which allows you to identify places with poorly written code. Deviations from the rules of clean code are always fertile ground for errors to occur, if not right now, then during future improvements to the application. Following the rules of clean code is absolutely necessary and therefore automatic testing by SonarCube must be included in the deployment pipeline.

6.2. Unit testing.

Writing Unit tests is an important tool for preventing "hidden" errors that can occur "by themselves". For example, careless "data cleaning" in the database can lead to some tests failing. Therefore, well-written Unit tests can "warn" the developer about problems that have arisen at the stage of application launch, when it is not too late to make the necessary corrections, which is not as painful as when a failure occurs during operation and can lead to financial or reputational losses for the customer enterprise, as well as reputational and financial losses for the developer himself.


7. Afterword

I am far from thinking that I have managed to cover all types and kinds of errors, the reasons for which they occur, as well as the whole variety of methods for finding the causes of occurrence and methods for correction. If the reader has a desire to improve this course, I will only be grateful.

I invite everyone who wants to supplement the course in any part, on any topic, to develop methods for working with errors, to expand it to any other programming languages, any IT sectors, any other industries where this can be effectively applied. If convenient, you can send materials for supplementation to my email (phaust@mail.ru), and I will, indicating the authorship, add corrections to this article, new sections, new aspects, interesting illustrative examples, etc.
